# Отчет о проверке кода "Project BlockVerse"

## 1. Критические несоответствия с описанием

### 1.1. Неверная иерархия мира
**Проблема**: В описании указано, что BigChunk должен содержать 4x4 чанка (64x64 блока), но в коде комментарий говорит о 32x32 чанка.

```13:13:internal/world/bigchunk.go
// BigChunk представляет собой единицу симуляции, которая содержит 32x32 чанка
```

**Исправление**: Нужно изменить логику создания и управления BigChunk'ами, чтобы они содержали именно 4x4 чанка.

### 1.2. Неверная частота обновления (TPS)
**Проблема**: В описании указан целевой TPS = 60, но в коде используется 20 TPS:

```88:88:internal/network/game_server_pb.go
		// Тикер для обновления игры с частотой 20 тиков в секунду
```

**Исправление**: Изменить интервал тикера с 50ms на ~16.67ms (1000/60).

### 1.3. Отсутствует система плагинов
**Проблема**: В описании указана система плагинов с динамической загрузкой `.so` файлов, но в коде реализован только статический реестр блоков.

```1:13:internal/world/block/implementations/init.go
func init() {
	// Базовые блоки
	block.Register(block.AirBlockID, &AirBehavior{})
	block.Register(block.StoneBlockID, &StoneBehavior{})
	block.Register(block.GrassBlockID, &GrassBehavior{})
	block.Register(block.WaterBlockID, &WaterBehavior{})
	block.Register(block.DirtBlockID, &DirtBehavior{})
}
```

**Исправление**: Необходимо реализовать динамическую загрузку плагинов из `.so` файлов.

### 1.4. Отсутствует JWT авторизация для администрирования
**Проблема**: В описании указана защита административного API через JWT токены, но реализация отсутствует. Найден только JWT в структуре AuthResponse:

```23:23:internal/network/message.go
	Token    string `json:"token"` // JWT токен для последующих запросов
```

Но нет никакой реализации генерации, проверки и использования JWT токенов.

## 2. Архитектурные проблемы

### 2.1. Неправильное преобразование координат BigChunk
**Проблема**: В методе GetChunk используется неверная формула для вычисления координат BigChunk:

```515:519:internal/world/world.go
	// Получаем координаты BigChunk, в котором находится чанк
	bigChunkCoords := vec.Vec2{
		X: (coords.X >> 4) * 4, // Преобразуем координаты чанка в координаты BigChunk
		Y: (coords.Y >> 4) * 4,
	}
```

Эта формула предполагает, что BigChunk содержит 16x16 чанков, а не 4x4.

**Исправление**: Правильная формула должна быть:
```go
bigChunkCoords := vec.Vec2{
    X: (coords.X / 4) * 4,
    Y: (coords.Y / 4) * 4,
}
```

### 2.2. Отсутствует REST API для администрирования
**Проблема**: В описании указан REST API для администрирования, но реализация отсутствует.

## 3. Потенциальные баги

### 3.1. Возможная утечка горутин
**Проблема**: BigChunk'и создаются и запускаются в горутинах, но нет механизма их остановки при выгрузке из памяти:

```267:270:internal/world/world.go
	bigChunk := NewBigChunk(coords, wm, wm.globalEvents)
	wm.bigChunks[coords] = bigChunk

	// Запускаем BigChunk в отдельной горутине
	go bigChunk.Run(wm.ctx)
```

**Исправление**: Нужно добавить механизм остановки неактивных BigChunk'ов.

### 3.2. Race condition при доступе к чанкам
**Проблема**: В некоторых местах кода доступ к чанкам происходит без блокировки:

```700:753:internal/network/game_handler_pb.go
			// Получаем данные чанка из мира
			chunk := gh.worldManager.GetChunk(chunkPos)
			if chunk == nil {
				continue
			}
```

### 3.3. Отсутствует проверка границ массива
**Проблема**: При доступе к блокам в чанке нет проверки границ:

```728:733:internal/network/game_handler_pb.go
				for blockX := 0; blockX < 16; blockX++ {
					localPos := vec.Vec2{X: blockX, Y: blockY}
					blockID := chunk.GetBlock(localPos)
					blockRow.BlockIds = append(blockRow.BlockIds, uint32(blockID))
				}
```

Метод GetBlock должен проверять, что координаты находятся в пределах 0-15.

### 3.4. Неправильная обработка Perlin noise
**Проблема**: В генераторе мира используется шум Перлина, но инициализация происходит каждый раз при проверке:

```19:22:internal/util/noise.go
	// Если генератор не инициализирован или используется другой сид, инициализируем его
	if perlinNoise == nil {
		InitPerlinNoise(seed)
	}
```

Проблема в том, что нет проверки, совпадает ли текущий сид с переданным.

## 4. Несоответствия в сетевом протоколе

### 4.1. Отсутствует разделение на TCP/UDP по типам сообщений
**Проблема**: В описании четко указано, какие сообщения должны идти через TCP, а какие через UDP. Но в коде эта логика не полностью соблюдается.

### 4.2. Неверный формат сообщений
**Проблема**: В описании указан формат: `[4 байта длина][2 байта тип][JSON]`, но в коде используется Protocol Buffers, а не JSON для основных сообщений.

## 5. Проблемы с механиками

### 5.1. Неверная логика распространения травы
**Проблема**: Трава пытается распространиться на блоки земли, но проверяет влажность:

```57:68:internal/world/block/implementations/grass.go
		// Проверяем, что блок по указанному направлению - земля
		if api.GetBlockID(targetPos) == block.DirtBlockID {
			// Проверяем влажность земли
			moisture, ok := api.GetBlockMetadata(targetPos, "moisture").(int)
			if ok && moisture >= 2 {
				// Превращаем землю в траву
				api.SetBlock(targetPos, block.GrassBlockID)
```

Но инициализация влажности земли происходит со значением 0:

```31:31:internal/world/block/implementations/dirt.go
func (b *DirtBehavior) CreateMetadata() block.Metadata {
	return block.Metadata{
		"moisture": 0,
	}
}
```

Это означает, что трава никогда не сможет распространиться естественным образом.

### 5.2. Отсутствует физика воды
**Проблема**: В реестре блоков есть WaterBlockID, но нет реализации поведения воды (течение, распространение).

## 6. Проблемы с производительностью

### 6.1. Неэффективная отправка чанков
**Проблема**: При отправке начальных чанков используется задержка 10ms между каждым чанком:

```746:746:internal/network/game_handler_pb.go
			time.Sleep(10 * time.Millisecond)
```

Для радиуса 5 это 121 чанк, что означает минимум 1.21 секунды на загрузку.

### 6.2. Отсутствует пулинг объектов
**Проблема**: При каждом тике создаются новые объекты событий, что создает нагрузку на GC.

## Рекомендации по исправлению

1. **Срочно**: Исправить размер BigChunk и формулы преобразования координат
2. **Важно**: Реализовать систему динамической загрузки плагинов
3. **Важно**: Добавить JWT авторизацию и REST API для администрирования
4. **Средне**: Исправить логику распространения травы
5. **Средне**: Добавить проверки границ массивов
6. **Низко**: Оптимизировать отправку чанков и добавить пулинг объектов

## Положительные моменты

1. Хорошая модульная архитектура
2. Правильное использование горутин для параллельной симуляции
3. Корректное использование мьютексов для синхронизации
4. Наличие системы событий для коммуникации между компонентами
5. Использование BadgerDB для эффективного хранения данных